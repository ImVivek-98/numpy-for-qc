{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Numpy for Quantum Computation\n",
    "Compiled and produced by [Vivek K R](https://www.linkedin.com/in/imvivek98/)\n",
    "#### Numpy module\n",
    "Numpy is a python library which can be used to perform a wide range of high-level mathematical functions. It is internally implemented in C++ and compiled directly to machine code, and hence is faster than python. It is preferred over conventional python lists due to its performance and ease of use (loops or custom functions are not required to do basic mathematical operations on vectors and matrices).\n",
    "\n",
    "#### Linear Algebra in Quantum Computing\n",
    "Linear algebra is in essence the language of quantum mechanics. All the states of a 2-level quantum system (qubit) are described as vectors in a complex vector space and these are denoted using matrices. All the operators we come across in quantum computation, which act upon states to give new states, can also be described using matrices. Hence understanding matrix operations such as matrix multiplication, tensor product etc. is imperative in understanding how these operators act on certain states. Also the problem of finding eigenvalues and eigenvectors of an operator becomes important in this regard.\n",
    "\n",
    "#### 5 numpy functions to know before getting started with Quantum Computing\n",
    "Numpy offers some very useful functions for tackling these problems and helps us deal with vectors and matrices rather easily and intuitively. Five of them are described in detail below:\n",
    "\n",
    "- `numpy.transpose` ([Transpose](https://en.wikipedia.org/wiki/Transpose))\n",
    "- `numpy.linalg.det` ([Determinant](https://en.wikipedia.org/wiki/Determinant))\n",
    "- `numpy.linalg.inv` ([Inverse](https://en.wikipedia.org/wiki/Invertible_matrix))\n",
    "- `numpy.kron` ([Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product))\n",
    "- `numpy.linalg.eig` ([Eigenvalues and eigenvectors](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors)) \n",
    "\n",
    "The recommended way to run this notebook is to click the \"Run\" button at the top of this page, and select \"Run on Binder\". This will run the notebook on mybinder.org, a free online service for running Jupyter notebooks. Alternatively, you could install Python and download this notebook on your computer to run it locally. The [conda](https://www.anaconda.com/products/individual#Downloads) distribution of python is recommended for this."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "!pip install jovian --upgrade -q"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import jovian"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/javascript": [
       "window.require && require([\"base/js/namespace\"],function(Jupyter){Jupyter.notebook.save_checkpoint()})"
      ],
      "text/plain": [
       "<IPython.core.display.Javascript object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[jovian] Attempting to save notebook..\n",
      "[jovian] Creating a new project \"imvivek-98/numpy-for-quantum-computation\"\n",
      "[jovian] Uploading notebook..\n",
      "[jovian] Capturing environment..\n",
      "[jovian] Committed successfully! https://jovian.ml/imvivek-98/numpy-for-quantum-computation\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "'https://jovian.ml/imvivek-98/numpy-for-quantum-computation'"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "jovian.commit(project='numpy-for-quantum-computation')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's begin by importing Numpy and listing out the functions covered in this notebook."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# List of functions explained \n",
    "function1 = np.transpose\n",
    "function2 = np.linalg.det \n",
    "function3 = np.linalg.inv \n",
    "function4 = np.kron \n",
    "function5 = np.linalg.eig "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Function 1 - `np.transpose(array,axes=None)`\n",
    "\n",
    "This function takes in a matrix in the form of an array and returns the transpose of it. Taking the transpose of a matrix can be thought of as switching its rows and columns, i.e., the first row becomes the first column, second row becomes the second column and so on.\n",
    "\n",
    "The axes argument lets us specify which rows and columns are to be switched and is particularly useful when dealing with arrays of 3 axes (dimensions) and above. It takes in a tuple or list of integers of the *n* axes of the input array. By default it reverses the order of the axes. i.e., for a two dimensional array `axes=(1,0)` and for a three dimensional array `axes=(2,1,0)`. Specifying the axes in the same order `axes=[0,1,2...n-1]` gives back the same array."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Example 1 - working"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[0, 3, 6],\n",
       "       [1, 4, 7],\n",
       "       [2, 5, 8]])"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "arr1_1 = np.array([[0,1,2],\n",
    "                   [3,4,5],\n",
    "                   [6,7,8]])\n",
    "\n",
    "np.transpose(arr1_1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here we can clearly see that the rows and columns have interchanged. The 0th axis took the place of the 1st axis and vice-versa. The matrix with `axes=(0,1)` has been transformed to `axes=(1,0)`. \n",
    "\n",
    "Now let us look at how this works out in a three-dimensional array.\n",
    "\n",
    "#### Example 2 - working"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[[ 0,  1,  2,  3],\n",
       "        [ 4,  5,  6,  7]],\n",
       "\n",
       "       [[ 8,  9, 10, 11],\n",
       "        [12, 13, 14, 15]],\n",
       "\n",
       "       [[16, 17, 18, 19],\n",
       "        [20, 21, 22, 23]]])"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "arr1_2 = np.arange(24).reshape((3,2,4))\n",
    "arr1_2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here we wish to take the transpose of the inner two-dimensional matrices from the three-dimensional array. i.e., we are looking to switch the 2nd and 3rd axes and not disturb the first axis. By default it assumes `axes=(2,1,0)`, but we need to change it to `axes=(0,2,1)`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[[ 0,  4],\n",
       "        [ 1,  5],\n",
       "        [ 2,  6],\n",
       "        [ 3,  7]],\n",
       "\n",
       "       [[ 8, 12],\n",
       "        [ 9, 13],\n",
       "        [10, 14],\n",
       "        [11, 15]],\n",
       "\n",
       "       [[16, 20],\n",
       "        [17, 21],\n",
       "        [18, 22],\n",
       "        [19, 23]]])"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.transpose(arr1_2,axes=(0,2,1))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We have successfully managed to take the transpose of just the inner matrices by giving the optional axes argument. Now let us see one final example to see where this function breaks.\n",
    "\n",
    "#### Example 3 - breaking"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[[ 0,  1],\n",
       "        [ 2,  3],\n",
       "        [ 4,  5]],\n",
       "\n",
       "       [[ 6,  7],\n",
       "        [ 8,  9],\n",
       "        [10, 11]],\n",
       "\n",
       "       [[12, 13],\n",
       "        [14, 15],\n",
       "        [16, 17]]])"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "arr1_3 = np.arange(18).reshape(3,3,2)\n",
    "arr1_3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "axes don't match array",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-10-015dae73e18d>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mnp\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mtranspose\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0marr1_3\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0maxes\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;32m<__array_function__ internals>\u001b[0m in \u001b[0;36mtranspose\u001b[1;34m(*args, **kwargs)\u001b[0m\n",
      "\u001b[1;32mc:\\users\\vivek\\anaconda3\\envs\\zerotopandas\\lib\\site-packages\\numpy\\core\\fromnumeric.py\u001b[0m in \u001b[0;36mtranspose\u001b[1;34m(a, axes)\u001b[0m\n\u001b[0;32m    651\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    652\u001b[0m     \"\"\"\n\u001b[1;32m--> 653\u001b[1;33m     \u001b[1;32mreturn\u001b[0m \u001b[0m_wrapfunc\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m'transpose'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0maxes\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    654\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    655\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\vivek\\anaconda3\\envs\\zerotopandas\\lib\\site-packages\\numpy\\core\\fromnumeric.py\u001b[0m in \u001b[0;36m_wrapfunc\u001b[1;34m(obj, method, *args, **kwds)\u001b[0m\n\u001b[0;32m     56\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     57\u001b[0m     \u001b[1;32mtry\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 58\u001b[1;33m         \u001b[1;32mreturn\u001b[0m \u001b[0mbound\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwds\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     59\u001b[0m     \u001b[1;32mexcept\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     60\u001b[0m         \u001b[1;31m# A TypeError occurs if the object does have such a method in its\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mValueError\u001b[0m: axes don't match array"
     ]
    }
   ],
   "source": [
    "np.transpose(arr1_3,axes=(1,0))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The axes argument in the function should be a list or tuple of integers given by the permutation of `[0,1,2...n-1]` where *n* is the number of axes of the input array. The function breaks when\n",
    "* the length of the tuple does not match the dimension of the array\n",
    "* A particular axis is being repeated in the tuple\n",
    "* There exists an element `i` in the tuple such that `i>=n`\n",
    "\n",
    "Here the number of axes of the input array is 3 but the length of the tuple is two, and hence the `ValueError`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Taking the hermitian transpose of an operator will give the corresponsing operator in the dual space (bra vector in the ket space and vice-versa) and hence is a recurring exercise when one tries to learn quantum computation or quantum mechanics. All the observables that exist in nature (things that you can measure) are identified with hermitian operators and hence it is a very important property for measuring quantum systems."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Function 2 - `np.linalg.det(array)`\n",
    "\n",
    "This function computes the determinant of an array. The last two dimensions of the input array must be a square (i.e., `array.shape[-1] == array.shape[-2]` should be **True**) or it throws up a `LinAlgError`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Example 1 - working"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-2.0000000000000004"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "arr2_1 = np.array([[1,2],\n",
    "                   [3,4]])\n",
    "np.linalg.det(arr2_1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here we can see that `np.linalg.det(arr2_1)` has given the determinant of the corresponding matrix. We can round up the determinant using the `np.around` function upto (say) 5 decimal places."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-2.0"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.around(np.linalg.det(arr2_1),5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This function throws up an error if the given matrix is not a square matrix. This is because the determinant is only defined for square matrices. Now let's see what happens when we compute the determinant of arrays with more than 2 dimensions. Make sure to shape the array such that the last two dimensions of the input array are equal.\n",
    "\n",
    "#### Example 2 - working"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "First we create a 4 dimensional matrix with random integers from 0-10 using the `np.random.rand` function and also the `np.around` function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[[[ 5.,  4.],\n",
       "         [ 0.,  5.]],\n",
       "\n",
       "        [[ 2.,  1.],\n",
       "         [ 4.,  7.]],\n",
       "\n",
       "        [[ 1.,  3.],\n",
       "         [ 5.,  2.]]],\n",
       "\n",
       "\n",
       "       [[[ 5., 10.],\n",
       "         [ 7.,  2.]],\n",
       "\n",
       "        [[ 8.,  5.],\n",
       "         [ 3.,  9.]],\n",
       "\n",
       "        [[10.,  2.],\n",
       "         [ 5.,  0.]]]])"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "arr2_2 = np.around(np.random.rand(2,3,2,2)*10)\n",
    "arr2_2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[ 25.,  10., -13.],\n",
       "       [-60.,  57., -10.]])"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.linalg.det(arr2_2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can see that while computing the determinant of an array with dimension (2,3,2,2), the function computed the the determinant of all the 2x2 square matrices (this is why the last two dimensions of the input array must be a square) and returned them in an array with dimension (2,3).\n",
    "\n",
    "Finally let's look at an example where the last two dimensions of the input array are not equal.\n",
    "\n",
    "#### Example 3 - breaking"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[[ 0,  1],\n",
       "        [ 2,  3],\n",
       "        [ 4,  5]],\n",
       "\n",
       "       [[ 6,  7],\n",
       "        [ 8,  9],\n",
       "        [10, 11]]])"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "arr2_3 = np.arange(12).reshape(2,3,2)\n",
    "arr2_3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "ename": "LinAlgError",
     "evalue": "Last 2 dimensions of the array must be square",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mLinAlgError\u001b[0m                               Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-16-37911241e71c>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mnp\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mlinalg\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdet\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0marr2_3\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;32m<__array_function__ internals>\u001b[0m in \u001b[0;36mdet\u001b[1;34m(*args, **kwargs)\u001b[0m\n",
      "\u001b[1;32mc:\\users\\vivek\\anaconda3\\envs\\zerotopandas\\lib\\site-packages\\numpy\\linalg\\linalg.py\u001b[0m in \u001b[0;36mdet\u001b[1;34m(a)\u001b[0m\n\u001b[0;32m   2154\u001b[0m     \u001b[0ma\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0masarray\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   2155\u001b[0m     \u001b[0m_assert_stacked_2d\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 2156\u001b[1;33m     \u001b[0m_assert_stacked_square\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   2157\u001b[0m     \u001b[0mt\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mresult_t\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0m_commonType\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   2158\u001b[0m     \u001b[0msignature\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;34m'D->D'\u001b[0m \u001b[1;32mif\u001b[0m \u001b[0misComplexType\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mt\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;32melse\u001b[0m \u001b[1;34m'd->d'\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\vivek\\anaconda3\\envs\\zerotopandas\\lib\\site-packages\\numpy\\linalg\\linalg.py\u001b[0m in \u001b[0;36m_assert_stacked_square\u001b[1;34m(*arrays)\u001b[0m\n\u001b[0;32m    202\u001b[0m         \u001b[0mm\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mn\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0ma\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;33m-\u001b[0m\u001b[1;36m2\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    203\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0mm\u001b[0m \u001b[1;33m!=\u001b[0m \u001b[0mn\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 204\u001b[1;33m             \u001b[1;32mraise\u001b[0m \u001b[0mLinAlgError\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'Last 2 dimensions of the array must be square'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    205\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    206\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0m_assert_finite\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0marrays\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mLinAlgError\u001b[0m: Last 2 dimensions of the array must be square"
     ]
    }
   ],
   "source": [
    "np.linalg.det(arr2_3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As expected a `LinAlgError` is raised since there were no square matrices to find the determinant of. This can be fixed by making the last two dimensions of the input array equal. i.e., `np.arange(12).reshape(3,2,2)`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Since quantum theory is unitary, all quantum gates are represented by unitary matrices. Unitary matrices are matrices whose hermitian transpose is equal to their inverse. The determinant is a special value which can be calculated from a square matrix which can help you determine whether a matrix has an inverse."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Function 3 - `np.linalg.inv(array)`\n",
    "\n",
    "This function calculates the inverse of a square matrix and hence the last two dimensions of the input array should be equal here too. Returns a `LinAlgError` if the input array does not contain a square matrix or if the matrix is non-invertible.\n",
    "\n",
    "#### Example 1 - working\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[-2. ,  1. ],\n",
       "       [ 1.5, -0.5]])"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "arr3_1 = np.array([[1,2],\n",
    "                   [3,4]])\n",
    "invarr3_1 = np.linalg.inv(arr3_1)\n",
    "invarr3_1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can check whether this matrix is indeed the inverse of the input matrix by checking whether the identity matrix is returned when the two matrices are multiplied using the `np.dot` function. We also use the `np.around` function to round up the values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1., 0.],\n",
       "       [0., 1.]])"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.around(np.dot(arr3_1,invarr3_1))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can see that `invarr3_1` is indeed the inverse of `arr3_1`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Example 2 - working\n",
    "\n",
    "Let us construct a three-dimensional array and make sure that the last two dimensions are equal."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[[ 0,  1],\n",
       "        [ 2,  3]],\n",
       "\n",
       "       [[ 4,  5],\n",
       "        [ 6,  7]],\n",
       "\n",
       "       [[ 8,  9],\n",
       "        [10, 11]]])"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "arr3_2 = np.arange(12).reshape(3,2,2)\n",
    "arr3_2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[[-1.5,  0.5],\n",
       "        [ 1. ,  0. ]],\n",
       "\n",
       "       [[-3.5,  2.5],\n",
       "        [ 3. , -2. ]],\n",
       "\n",
       "       [[-5.5,  4.5],\n",
       "        [ 5. , -4. ]]])"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "invarr3_2 = np.linalg.inv(arr3_2)\n",
    "invarr3_2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`invarr3_2` consists of the inverses of the three 2x2 square matrices contained in `arr3_2`. This can be verified by doing matrix multiplications of the corresponding matrices : `np.dot(arr3_2[0],invarra3_2[0])`,`np.dot(arr3_2[1],invarra3_2[1])` and `np.dot(arr3_2[2],invarra3_2[2])`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Example 3 - breaking"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "ename": "LinAlgError",
     "evalue": "Singular matrix",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mLinAlgError\u001b[0m                               Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-21-5a78093446e3>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      1\u001b[0m arr3_3 = np.array([[6,2],\n\u001b[0;32m      2\u001b[0m                    [9,3]])\n\u001b[1;32m----> 3\u001b[1;33m \u001b[0mnp\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mlinalg\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0minv\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0marr3_3\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;32m<__array_function__ internals>\u001b[0m in \u001b[0;36minv\u001b[1;34m(*args, **kwargs)\u001b[0m\n",
      "\u001b[1;32mc:\\users\\vivek\\anaconda3\\envs\\zerotopandas\\lib\\site-packages\\numpy\\linalg\\linalg.py\u001b[0m in \u001b[0;36minv\u001b[1;34m(a)\u001b[0m\n\u001b[0;32m    544\u001b[0m     \u001b[0msignature\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;34m'D->D'\u001b[0m \u001b[1;32mif\u001b[0m \u001b[0misComplexType\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mt\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;32melse\u001b[0m \u001b[1;34m'd->d'\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    545\u001b[0m     \u001b[0mextobj\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mget_linalg_error_extobj\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0m_raise_linalgerror_singular\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 546\u001b[1;33m     \u001b[0mainv\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0m_umath_linalg\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0minv\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0msignature\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0msignature\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mextobj\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mextobj\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    547\u001b[0m     \u001b[1;32mreturn\u001b[0m \u001b[0mwrap\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mainv\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mastype\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mresult_t\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mcopy\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;32mFalse\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    548\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\vivek\\anaconda3\\envs\\zerotopandas\\lib\\site-packages\\numpy\\linalg\\linalg.py\u001b[0m in \u001b[0;36m_raise_linalgerror_singular\u001b[1;34m(err, flag)\u001b[0m\n\u001b[0;32m     86\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     87\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0m_raise_linalgerror_singular\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0merr\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mflag\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 88\u001b[1;33m     \u001b[1;32mraise\u001b[0m \u001b[0mLinAlgError\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"Singular matrix\"\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     89\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     90\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0m_raise_linalgerror_nonposdef\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0merr\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mflag\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mLinAlgError\u001b[0m: Singular matrix"
     ]
    }
   ],
   "source": [
    "arr3_3 = np.array([[6,2],\n",
    "                   [9,3]])\n",
    "np.linalg.inv(arr3_3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The function breaks for this particular matrix because it is singular and hence non-invertible. We can verify this by showing that the determinant of this particular matrix is 0 by using the `np.linalg.det(arr3_3)` function described earlier."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.0"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.linalg.det(arr3_3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "An inverse simply doesn't exist for these kind of matrices and hence python raises a `LinAlgError`. You also get a `LinAlgError` when the last two dimensions of the array is not a square."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Function 4 - `np.kron(array1,array2)`\n",
    "\n",
    "This function computes the Kronecker product (which is also used interchangeably with Tensor product in quantum computation) of two matrices. It is simply a composite array made of blocks of the second array scaled by the first. For example, the kronecker product of two matrices **A** and **B** is\n",
    "![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARUAAABbCAMAAABqFeF4AAAASFBMVEX///8AAAB+fn7u7u4+Pj7x8fFsbGxwcHC+vr5eXl5OTk7f39/Ozs4PDw+dnZ2Ojo4eHh4uLi6tra35+fm2trbm5uY7OztgYGAj1pr/AAAGq0lEQVR4nO2caYOrKgyG2c7IjngX//8/vYm7FrXT4zbn8n6Ydqxt8DEECmkIybpOf7FG1d3teEO8berfF5j6RRupC0z9rkzb1OICU7/o1zuncTno7BY1Gs3xRUOeRMWKSKkTQjjqwtltAgkBXgHmSkrrGZdHUYG7B63ER02pP7NBvYAKPvjObK+HUpGLZp6ljgo+Tp0lU+kf76fCQ1Fxmzhx0oOOG8Z5YBU3yZc6KnIxPt5CxZbMKJdyBmheCbMFQcVxo5B1wagy7XpABczVYHR2+A4qvNTYoPbutPeQd/7bUWGlqxeD5cfiTuEspJhYG9VSgbugZ557BxVGLV4/DDKSNTfJF65zjb4HcUfj+sd9dd3LONceqDauoqAGT4B3yGLhEmNcEdRNsdxBpSwJooHGGi6wnZaLBRVo5sbQrLvXBiph4ypoa40P1mYvdlQYpXpy+AYqvGmAKJt/unamqCyvYKL+vhq+OPAq0/RUEUdrxsAkuntjT2UxYbnDV5rrhd4uyCoVDtPN9Sv9jgxa42C/t2aKWITQ9c+eip7fhDuoRPhHUSYZWVDhMlAa4WtJiMd9Pyu/CK9pqHprwZQBWOFLEm4CBXMeoMS75ys2Cg2RT3OyoGLFIHXYyGxLoWxRisEaEvGNR47m9DyI3T23XfSgk9VYQyI6pGd1nf6HVBT8oWZzredeKrIG7zVEavDh81uB1rQhNYRxVW/G8rt95ZnKVFLKVFLKVFLKVFLKVFLKVFLKVFLKVFLKVFLKVFLKVFLKVFLKVFLKVFK6hso/9N8LrBwnk9zllsXmAh6IdQpy70wU/xFpTqM4rRNHxdZmTHuGcE1CjIC/+3uff0QPspS6lxMlm7uFGLbz93Mq/ggqii73M3ktWGBaT7h0VEhJ6W4n+hOocFcuHMCU7Rq8nOxR91TcEVTCFWlwgzjb2ZdMUfHULC416jb6KD1usXVUqncSRveomHmq0dlie50+RSUq7EOT454RhViUIn64qaJJ/dA0jn3NSJlO1tz1leJb84Ov30yEsnpn+ylBxVK5iLcYTgALQCF8oNxSASzjDpdkE0197eC4os9OsExQUZhDEafxNraH1fAcJcbt/N2Nv4OpJFPqDjXwQgVibZuYO/a95pkqm9jyQsXPE2KS+vljkG86BpvGW8wegO6DsWXWg5rHauR3VQ86Xa9UYjukTOMtRls8Clhm0bZ5nCTE8I+j7Yey73zd+EAjFcswdYwVVONFshriLesvV+gO1TAyM1b20XaeEJPULhXxUc6xeZ2CvyUZd6L1SEXgvKPNqyFDwktv/mUWN8m/eWM8eGO+sv8hicaXG4mWGwp7kXCk4rfuF1cR/UJ9ONfa9ZWLfvrSiVc71zGJK3wTIJdh+Sua9/WDo60/b2r0c6nwN9ZJPtXZVDg7djCajEEnThjPXqFk+xPJbym9Qnm0zvYVK479+esz1vg/HWI/VLW3APsMKjAdu3J95RvzlTO124PMSVP3Fe3NMR5C5WHKVFLKVFLKVFLKVFLKVFLKVFLKVFLKVFLKVFLKVFLKVFJ6GhU/7LJdUjDMDOb89Pvp06gUuJcbmy1ddwGXppIU7iDH2Y/fn0alKeSA2yAcsFyxvCA7HLNKUo+lglu6VxS86qnM8vueS2Wz1shx6qn4ac7WHVS80NavroZ1VCzdqkvzDYVNaz0VHqd1aa6nwoXgEDRWt1BZG20P8hQeFTduo2qJbKOto9Pd4uupFLhwrV9323sIQCVgsRHnVhfieY90WO5dZazQmthIXcDyX2CuilSPWC6n0tbOictdKC16Tn1c8eslWDQN3WcNFYxW8jhl8xnlxpJ+H1f4tMdeToVh/iN/3ZCRSyqGrqZv9DmU3HUXsrrBw/CzDN3I5u2pYHQfPO5yKhozaysqOSfBkCpw7qu2dd0JPRW+TuV9NR7oqW2s8coT4/HD8Xk3R3wGlQLbqSgpKiadskoUVniSoMKOKLqoO2vKhgqt1YWNkrBQFla1DtRTwVzaIbBcTkVSQyCSEkG8hGYwuHIRyEDFM7hn6t3Msl1V4JnBCS5IkCVYgwAjKhIqeF401YwYTBYFlhd01N05tw1aeaOjxWdYSoiQZqLQUSmGzLLikJE5CFVZIcACg4AMXskxNRRTwUvsQmMlKRVuHZlHdUSqEgdW+ftBZFvYT4GIjzCux4pYR9a/fd5JBYhA2wgrgkVfP7kNQESW4CYMQi32q1reTyVRTRzz8LBmnK19+4u9U7/2YHmrKqC1ipgCi+mlh+sLq4nnyvNZ/w/9Bwq4M0bkIzgBAAAAAElFTkSuQmCC)\n",
    "\n",
    "#### Example 1 - working"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[ 1,  1,  0,  0],\n",
       "       [ 1,  1,  0,  0],\n",
       "       [ 0,  0, -1, -1],\n",
       "       [ 0,  0, -1, -1]])"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "arr4_1a = np.array([[1,0],\n",
    "                    [0,-1]])\n",
    "arr4_1b = np.array([[1,1],\n",
    "                    [1,1]])\n",
    "np.kron(arr4_1a,arr4_1b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The function has calculated `arr4_1a` âŠ— `arr4_1b`. Notice that taking the kronecker product of two 2x2 matrices gave a 4x4 matrix. This is a very general rule wherein if the dimension of **A** is (m,n) and the dimension of **B** is (o,p), the dimension of **A** âŠ— **B** is (m\\*o,n\\*p).\n",
    "\n",
    "Also notice that `np.kron(arr4_1a,arr4_1b)` is not the same as `np.kron(arr4_1b,arr4_1a)`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Example 2 - working\n",
    "\n",
    "Now we try to take the kronecker product of arrays with different dimensions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "arr4_2a = np.arange(100).reshape((2,5,2,5))\n",
    "arr4_2b = np.arange(24).reshape((2,3,4))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(2, 5, 2, 5) (2, 3, 4)\n"
     ]
    }
   ],
   "source": [
    "print(arr4_2a.shape,arr4_2b.shape)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Since the kronecker product of the arrays would be very large, we just display it's dimensions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(2, 10, 6, 20)"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.kron(arr4_2b,arr4_2a).shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can see that numpy automatically takes the arrays corresponding to the last three dimensions (because the array with the least number of dimensions is 3-dimensional), and computes the kronecker product. This generates the array given above."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Example 3 - breaking\n",
    "\n",
    "Kronecker product can be computed for two matrices of arbitrary size and hence should work in most cases. The inputs can be arrays, lists, tuples or even integers. However the function breaks if we pass in an empty array."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "need at least one array to concatenate",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-27-7adbc9d6204a>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[0marr4_3b\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mones\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m2\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m2\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      3\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 4\u001b[1;33m \u001b[0mnp\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mkron\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0marr4_3a\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0marr4_3b\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;32m<__array_function__ internals>\u001b[0m in \u001b[0;36mkron\u001b[1;34m(*args, **kwargs)\u001b[0m\n",
      "\u001b[1;32mc:\\users\\vivek\\anaconda3\\envs\\zerotopandas\\lib\\site-packages\\numpy\\lib\\shape_base.py\u001b[0m in \u001b[0;36mkron\u001b[1;34m(a, b)\u001b[0m\n\u001b[0;32m   1155\u001b[0m     \u001b[0maxis\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mnd\u001b[0m\u001b[1;33m-\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1156\u001b[0m     \u001b[1;32mfor\u001b[0m \u001b[0m_\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mrange\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mnd\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 1157\u001b[1;33m         \u001b[0mresult\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mconcatenate\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mresult\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0maxis\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   1158\u001b[0m     \u001b[0mwrapper\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mget_array_prepare\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mb\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1159\u001b[0m     \u001b[1;32mif\u001b[0m \u001b[0mwrapper\u001b[0m \u001b[1;32mis\u001b[0m \u001b[1;32mnot\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m<__array_function__ internals>\u001b[0m in \u001b[0;36mconcatenate\u001b[1;34m(*args, **kwargs)\u001b[0m\n",
      "\u001b[1;31mValueError\u001b[0m: need at least one array to concatenate"
     ]
    }
   ],
   "source": [
    "arr4_3a = np.array([])\n",
    "arr4_3b = np.ones((2,2))\n",
    "\n",
    "np.kron(arr4_3a,arr4_3b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Understanding Kronecker product is imperative in studying and doing computations with multiple qubits. It is a generalization of the outer product (which is denoted by the same symbol) from vectors to matrices, and gives the matrix of the tensor product with respect to a standard choice of basis.The terms Kronecker product, Direct product, outer product and Tensor product are used interchangeably in the quantum community (look up the internet if you want to know about the subtle differences between them)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Function 5 - `np.linalg.eig(array)`\n",
    "\n",
    "This function takes in a square matrix and returns a 2-tuple containing the eigenvalues and eigenvectors as arrays. Again, as in the case with the functions `np.linalg.det` and `np.linalg.inv`, the last two dimensions of the input array should be equal and should form a square matrix.\n",
    "# <div align=\"center\">A **x** = *Î»* **x**</div>\n",
    "Here the vector **x** is the eigenvector and the scalar **Î»** is the eigenvalue."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Example 1 - working\n",
    "\n",
    "Let's try to find the eigenvalues and eigenvectors of the Pauli-Z matrix."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(array([ 1., -1.]),\n",
       " array([[1., 0.],\n",
       "        [0., 1.]]))"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "arr5_1 = np.array([[1,0],\n",
    "                   [0,-1]])\n",
    "np.linalg.eig(arr5_1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As expected, here we can see that the Pauli-Z matrix has 1 and -1 as their eigen values, and [1,0] and [0,1] as their eigenvectors."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Example 2 - working\n",
    "\n",
    "We can also find the eigenvalues and eigenvectors for multiple matrices by making use of 3-dimensional arrays. Let's try this out with the Pauli-Z, Pauli-X and Pauli-Y matrices."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[[ 0.+0.j  1.+0.j]\n",
      "  [ 1.+0.j  0.+0.j]]\n",
      "\n",
      " [[ 0.+0.j -0.-1.j]\n",
      "  [ 0.+1.j  0.+0.j]]\n",
      "\n",
      " [[ 1.+0.j  0.+0.j]\n",
      "  [ 0.+0.j -1.+0.j]]] \n",
      "\n",
      "Dimensions:  (3, 2, 2)\n"
     ]
    }
   ],
   "source": [
    "paulix = np.array([[0,1],\n",
    "                   [1,0]])\n",
    "\n",
    "pauliy = np.array([[0,-1j],\n",
    "                   [1j,0]])\n",
    "\n",
    "pauliz = np.array([[1,0],\n",
    "                   [0,-1]])\n",
    "\n",
    "arr5_2 = np.array([paulix,pauliy,pauliz])\n",
    "\n",
    "print(arr5_2,'\\n\\nDimensions: ',arr5_2.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(array([[ 1.+0.j, -1.+0.j],\n",
       "        [ 1.+0.j, -1.+0.j],\n",
       "        [ 1.+0.j, -1.+0.j]]),\n",
       " array([[[ 0.70710678-0.j        ,  0.70710678+0.j        ],\n",
       "         [ 0.70710678+0.j        , -0.70710678-0.j        ]],\n",
       " \n",
       "        [[-0.        -0.70710678j,  0.70710678+0.j        ],\n",
       "         [ 0.70710678+0.j        ,  0.        -0.70710678j]],\n",
       " \n",
       "        [[ 1.        +0.j        ,  0.        +0.j        ],\n",
       "         [ 0.        +0.j        ,  1.        +0.j        ]]]))"
      ]
     },
     "execution_count": 30,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.linalg.eig(arr5_2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can see that all the eigenvalues and eigenvectors for each of the Pauli matrices were computed. This idea can be extended to more than 3-dimensions with the constraint that the last two dimensions should be square."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Example 3 - breaking"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[0, 1],\n",
       "       [2, 3],\n",
       "       [4, 5]])"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "arr5_3 = np.arange(6).reshape(3,2)\n",
    "arr5_3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "ename": "LinAlgError",
     "evalue": "Last 2 dimensions of the array must be square",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mLinAlgError\u001b[0m                               Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-32-01a0c92bd4fa>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mnp\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mlinalg\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0meig\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0marr5_3\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;32m<__array_function__ internals>\u001b[0m in \u001b[0;36meig\u001b[1;34m(*args, **kwargs)\u001b[0m\n",
      "\u001b[1;32mc:\\users\\vivek\\anaconda3\\envs\\zerotopandas\\lib\\site-packages\\numpy\\linalg\\linalg.py\u001b[0m in \u001b[0;36meig\u001b[1;34m(a)\u001b[0m\n\u001b[0;32m   1315\u001b[0m     \u001b[0ma\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mwrap\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0m_makearray\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1316\u001b[0m     \u001b[0m_assert_stacked_2d\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 1317\u001b[1;33m     \u001b[0m_assert_stacked_square\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   1318\u001b[0m     \u001b[0m_assert_finite\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1319\u001b[0m     \u001b[0mt\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mresult_t\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0m_commonType\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\vivek\\anaconda3\\envs\\zerotopandas\\lib\\site-packages\\numpy\\linalg\\linalg.py\u001b[0m in \u001b[0;36m_assert_stacked_square\u001b[1;34m(*arrays)\u001b[0m\n\u001b[0;32m    202\u001b[0m         \u001b[0mm\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mn\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0ma\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;33m-\u001b[0m\u001b[1;36m2\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    203\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0mm\u001b[0m \u001b[1;33m!=\u001b[0m \u001b[0mn\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 204\u001b[1;33m             \u001b[1;32mraise\u001b[0m \u001b[0mLinAlgError\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'Last 2 dimensions of the array must be square'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    205\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    206\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0m_assert_finite\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0marrays\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mLinAlgError\u001b[0m: Last 2 dimensions of the array must be square"
     ]
    }
   ],
   "source": [
    "np.linalg.eig(arr5_3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As already mentioned, since the input matrix is not a square matrix, i.e., the last two dimensions of the array are not equal, it raises a `LinAlgError`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Eigenvalues and eigenvectors are one of the central concepts of Quantum Mechanics as well as Quantum Computation. All operators (gates) that are applied on qubits (quantum bits) can be represented in a matrix form and finding the eigenvalues and eigenvectors of that particular operator gives us an idea about the corresponding physical parameters that the quantum mechanical operator is associated with. For example, the operator associated with energy is called the *Hamiltonian* and the operation of the hamiltonian on the wavefunction (also called the time-independent SchrÃ¶dinger equation) gives energy as its eigenvalues."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Conclusion\n",
    "\n",
    "In this notebook we have looked at 5 numpy functions that would be useful when looking to simulate quantum mechanics or learn quantum computation. These are mostly functions related to linear algebra, which is not surprising because linear algebra is in essence the language of quantum mechanics. Often when we try to do simulations in quantum computers, by making use of various quantum computing programming languages like *Qiskit* and *Q#*, we come across situations where we need to compare the measured value of our experiments with the exact ones. This is very much required in this era of Noisy Intermediate-Scale Quantum (NISQ) computing due to the large amount of noise induced by simple individual gates. We can make use of these simple numpy functions to compute exact values and compare them to the obtained values, thereby helping to reduce unwanted noise and errors."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## For further reading\n",
    "* [Numpy functions list](https://numpy.org/doc/stable/reference/routines.html)\n",
    "* [Essence of linear algebra by 3Blue1Brown](http://3b1b.co/eola)\n",
    "* [Quantum Mechanics course by Prof. Leonard Susskind](https://www.youtube.com/playlist?list=PL701CD168D02FF56F)\n",
    "* [Qiskit Textbook for Quantum Computation](https://qiskit.org/textbook/preface.html)\n",
    "* [Qiskit Global Summer School 2020](https://www.youtube.com/playlist?list=PLOFEBzvs-VvrXTMy5Y2IqmSaUjfnhvBHR)\n",
    "* [Linear Algebra for Quantum Computing by Microsoft](https://docs.microsoft.com/en-us/quantum/overview/algebra-for-quantum-computing)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/javascript": [
       "window.require && require([\"base/js/namespace\"],function(Jupyter){Jupyter.notebook.save_checkpoint()})"
      ],
      "text/plain": [
       "<IPython.core.display.Javascript object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[jovian] Attempting to save notebook..\r\n"
     ]
    }
   ],
   "source": [
    "jovian.commit()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
